#version 450

#define MAX_LIGHTS 100

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer LightsBuffer {
    vec4 lightCount;
    vec4 lightParams;
    vec4 lightFlags;
    vec4 lightBeam[MAX_LIGHTS];
    vec4 lightPosRange[MAX_LIGHTS];
    vec4 lightColorIntensity[MAX_LIGHTS];
    vec4 lightDirInner[MAX_LIGHTS];
    vec4 lightOther[MAX_LIGHTS];
} uLights;

layout(std140, binding = 1) uniform CullParams {
    mat4 view;
    mat4 proj;
    vec4 screen; // x=width y=height z=invW w=invH
    vec4 cluster; // x=countX y=countY z=countZ w=clusterSize
    vec4 zParams; // x=logScale y=logBias z=near w=far
    vec4 flags;   // x=enabled
} uCull;

layout(r32ui, binding = 2) uniform uimage2D lightIndexImage;

void main()
{
    uint clusterX = gl_GlobalInvocationID.x;
    uint clusterY = gl_GlobalInvocationID.y;
    uint clusterZ = gl_GlobalInvocationID.z;
    uint countX = uint(uCull.cluster.x + 0.5);
    uint countY = uint(uCull.cluster.y + 0.5);
    uint countZ = uint(uCull.cluster.z + 0.5);
    if (clusterX >= countX || clusterY >= countY || clusterZ >= countZ)
        return;

    uint row = (clusterZ * countY + clusterY) * countX + clusterX;
    uint count = 0u;

    float clusterSize = uCull.cluster.w;
    float minX = float(clusterX) * clusterSize;
    float minY = float(clusterY) * clusterSize;
    float maxX = min(minX + clusterSize, uCull.screen.x);
    float maxY = min(minY + clusterSize, uCull.screen.y);

    float logScale = uCull.zParams.x;
    float logBias = uCull.zParams.y;
    float zNear = uCull.zParams.z;
    float zFar = uCull.zParams.w;
    float sliceNear = exp2((float(clusterZ) - logBias) / logScale);
    float sliceFar = exp2((float(clusterZ) + 1.0 - logBias) / logScale);
    sliceNear = max(sliceNear, zNear);
    sliceFar = min(sliceFar, zFar);

    int lightCount = int(uLights.lightCount.x);
    for (int i = 0; i < lightCount; ++i)
    {
        vec4 other = uLights.lightOther[i];
        int type = int(other.y + 0.5);
        if (type == 0)
        {
            if (count < uint(MAX_LIGHTS))
            {
                imageStore(lightIndexImage, ivec2(1 + int(count), int(row)), uvec4(uint(i), 0u, 0u, 0u));
                count += 1u;
            }
            continue;
        }
        vec4 pr = uLights.lightPosRange[i];
        float range = pr.w;
        if (range <= 0.0)
            continue;

        vec4 viewPos = uCull.view * vec4(pr.xyz, 1.0);
        float z = -viewPos.z;
        if (z <= 0.001)
            continue;
        float lightMinZ = z - range;
        float lightMaxZ = z + range;
        if (lightMaxZ < sliceNear || lightMinZ > sliceFar)
            continue;

        float projScale = max(uCull.proj[0][0], uCull.proj[1][1]);
        float radiusNdc = range * projScale / z;
        vec4 clip = uCull.proj * viewPos;
        if (clip.w <= 0.0)
            continue;
        vec2 ndc = clip.xy / clip.w;
        float screenX = (ndc.x * 0.5 + 0.5) * uCull.screen.x;
        float screenY = (ndc.y * 0.5 + 0.5) * uCull.screen.y;
        float radiusX = radiusNdc * 0.5 * uCull.screen.x;
        float radiusY = radiusNdc * 0.5 * uCull.screen.y;
        float radius = max(radiusX, radiusY);

        if (screenX + radius < minX || screenX - radius > maxX
                || screenY + radius < minY || screenY - radius > maxY)
            continue;

        if (count < uint(MAX_LIGHTS))
        {
            imageStore(lightIndexImage, ivec2(1 + int(count), int(row)), uvec4(uint(i), 0u, 0u, 0u));
            count += 1u;
        }
    }

    imageStore(lightIndexImage, ivec2(0, int(row)), uvec4(count, 0u, 0u, 0u));
}
